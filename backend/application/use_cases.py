"""
Application Layer - Use Cases
SOLID Principle: Single Responsibility - Each use case does one thing
SOLID Principle: Dependency Inversion - Depends on repository interfaces
"""

from typing import Optional, List
from datetime import timedelta
from decimal import Decimal

from domain.entities import User, Product, Category, Banner, Order, OrderItem, UserRole, OrderStatus
from domain.repositories import (
    IUserRepository, 
    IProductRepository, 
    ICategoryRepository,
    IBannerRepository,
    IOrderRepository
)
from infrastructure.utils.password_utils import hash_password, verify_password
from infrastructure.utils.jwt_utils import create_access_token
from infrastructure.utils.image_utils import process_upload_image
from application.dto import (
    UserCreateDTO, UserUpdateDTO, LoginDTO,
    ProductCreateDTO, ProductUpdateDTO,
    CategoryCreateDTO, CategoryUpdateDTO,
    BannerCreateDTO, BannerUpdateDTO,
    OrderCreateDTO
)


class RegisterUserUseCase:
    """Use Case: Register a new user"""
    
    def __init__(self, user_repository: IUserRepository):
        self.user_repository = user_repository
    
    async def execute(self, dto: UserCreateDTO) -> User:
        # Check if email already exists
        existing_user = await self.user_repository.get_by_email(dto.email)
        if existing_user:
            raise ValueError("Email already registered")
        
        # Hash password
        hashed_password = hash_password(dto.password)
        
        # Create user entity
        user = User(
            id="",  # Will be generated by database
            email=dto.email,
            password=hashed_password,
            name=dto.name,
            role=UserRole.CUSTOMER,
            phone=dto.phone,
            address=dto.address
        )
        
        return await self.user_repository.create(user)


class LoginUserUseCase:
    """Use Case: User login"""
    
    def __init__(self, user_repository: IUserRepository):
        self.user_repository = user_repository
    
    async def execute(self, dto: LoginDTO) -> tuple[str, User]:
        # Get user by email
        user = await self.user_repository.get_by_email(dto.email)
        if not user:
            raise ValueError("Invalid email or password")
        
        # Verify password
        if not verify_password(dto.password, user.password):
            raise ValueError("Invalid email or password")
        
        # Create access token
        token_data = {
            "sub": user.id,
            "email": user.email,
            "role": user.role.value
        }
        access_token = create_access_token(token_data)
        
        return access_token, user


class UpdateUserProfileUseCase:
    """Use Case: Update user profile"""
    
    def __init__(self, user_repository: IUserRepository):
        self.user_repository = user_repository
    
    async def execute(self, user_id: str, dto: UserUpdateDTO) -> User:
        user = await self.user_repository.get_by_id(user_id)
        if not user:
            raise ValueError("User not found")
        
        # Update fields
        if dto.name is not None:
            user.name = dto.name
        if dto.phone is not None:
            user.phone = dto.phone
        if dto.address is not None:
            user.address = dto.address
        
        # Process avatar if provided
        if dto.avatar is not None:
            success, processed_image, error = process_upload_image(dto.avatar)
            if not success:
                raise ValueError(error)
            user.avatar = processed_image
        
        return await self.user_repository.update(user)


class CreateProductUseCase:
    """Use Case: Create a new product (Admin only)"""
    
    def __init__(self, product_repository: IProductRepository):
        self.product_repository = product_repository
    
    async def execute(self, dto: ProductCreateDTO) -> Product:
        # Check if slug already exists
        existing = await self.product_repository.get_by_slug(dto.slug)
        if existing:
            raise ValueError("Product slug already exists")
        
        # Process main image
        success, processed_image, error = process_upload_image(dto.image)
        if not success:
            raise ValueError(f"Main image error: {error}")
        
        # Process gallery images if provided
        processed_images = []
        if dto.images:
            for img in dto.images:
                success, processed, error = process_upload_image(img)
                if success:
                    processed_images.append(processed)
        
        # Create product entity
        product = Product(
            id="",
            name=dto.name,
            slug=dto.slug,
            description=dto.description,
            price=dto.price,
            category_id=dto.category_id,
            discount=dto.discount,
            stock=dto.stock,
            image=processed_image,
            images=processed_images,
            featured=dto.featured
        )
        
        return await self.product_repository.create(product)


class UpdateProductUseCase:
    """Use Case: Update product (Admin only)"""
    
    def __init__(self, product_repository: IProductRepository):
        self.product_repository = product_repository
    
    async def execute(self, product_id: str, dto: ProductUpdateDTO) -> Product:
        product = await self.product_repository.get_by_id(product_id)
        if not product:
            raise ValueError("Product not found")
        
        # Update fields
        if dto.name is not None:
            product.name = dto.name
        if dto.description is not None:
            product.description = dto.description
        if dto.price is not None:
            product.price = dto.price
        if dto.category_id is not None:
            product.category_id = dto.category_id
        if dto.discount is not None:
            product.discount = dto.discount
        if dto.stock is not None:
            product.stock = dto.stock
        if dto.featured is not None:
            product.featured = dto.featured
        
        # Process main image if provided
        if dto.image is not None:
            success, processed_image, error = process_upload_image(dto.image)
            if not success:
                raise ValueError(f"Main image error: {error}")
            product.image = processed_image
        
        # Process gallery images if provided
        if dto.images is not None:
            processed_images = []
            for img in dto.images:
                success, processed, error = process_upload_image(img)
                if success:
                    processed_images.append(processed)
            product.images = processed_images
        
        return await self.product_repository.update(product)


class GetProductsUseCase:
    """Use Case: Get products list"""
    
    def __init__(self, product_repository: IProductRepository):
        self.product_repository = product_repository
    
    async def execute(
        self, 
        skip: int = 0, 
        limit: int = 100,
        category_id: Optional[str] = None,
        featured: Optional[bool] = None
    ) -> List[Product]:
        return await self.product_repository.get_all(
            skip=skip,
            limit=limit,
            category_id=category_id,
            featured=featured
        )


class CreateCategoryUseCase:
    """Use Case: Create category (Admin only)"""
    
    def __init__(self, category_repository: ICategoryRepository):
        self.category_repository = category_repository
    
    async def execute(self, dto: CategoryCreateDTO) -> Category:
        # Process image if provided
        processed_image = None
        if dto.image:
            success, processed_image, error = process_upload_image(dto.image)
            if not success:
                raise ValueError(f"Image error: {error}")
        
        category = Category(
            id="",
            name=dto.name,
            slug=dto.slug,
            description=dto.description,
            image=processed_image
        )
        
        return await self.category_repository.create(category)


class UpdateBannerUseCase:
    """Use Case: Update banner (Admin only)"""
    
    def __init__(self, banner_repository: IBannerRepository):
        self.banner_repository = banner_repository
    
    async def execute(self, banner_id: str, dto: BannerUpdateDTO) -> Banner:
        # Note: You'll need to add get_by_id to IBannerRepository
        # For now, this is a placeholder showing the pattern
        
        # Process image if provided
        if dto.image is not None:
            success, processed_image, error = process_upload_image(dto.image)
            if not success:
                raise ValueError(f"Image error: {error}")
            # Update banner image
        
        # Return updated banner
        pass


class CreateOrderUseCase:
    """Use Case: Create order"""
    
    def __init__(
        self, 
        order_repository: IOrderRepository,
        product_repository: IProductRepository
    ):
        self.order_repository = order_repository
        self.product_repository = product_repository
    
    async def execute(self, user_id: str, dto: OrderCreateDTO) -> Order:
        # Validate products and calculate totals
        total_amount = Decimal("0")
        order_items = []
        
        for item_dto in dto.items:
            product = await self.product_repository.get_by_id(item_dto.product_id)
            if not product:
                raise ValueError(f"Product {item_dto.product_id} not found")
            
            if product.stock < item_dto.quantity:
                raise ValueError(f"Insufficient stock for {product.name}")
            
            # Calculate item totals
            item_price = product.price
            item_discount = product.discount
            item_subtotal = item_price * item_dto.quantity
            
            if item_discount > 0:
                discount_amount = (item_subtotal * item_discount) / Decimal("100")
                item_subtotal -= discount_amount
            
            total_amount += item_subtotal
            
            order_item = OrderItem(
                id="",
                order_id="",  # Will be set after order creation
                product_id=product.id,
                quantity=item_dto.quantity,
                price=item_price,
                discount=item_discount,
                subtotal=item_subtotal
            )
            order_items.append(order_item)
        
        # Calculate shipping and final amount
        shipping_fee = Decimal("30000") if total_amount < Decimal("500000") else Decimal("0")
        final_amount = total_amount + shipping_fee
        
        # Create order
        import uuid
        from datetime import datetime
        
        order = Order(
            id="",
            order_number=f"ORD-{datetime.now().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}",
            user_id=user_id,
            status=OrderStatus.PENDING,
            total_amount=total_amount,
            shipping_fee=shipping_fee,
            discount_amount=Decimal("0"),
            final_amount=final_amount,
            shipping_name=dto.shipping_name,
            shipping_phone=dto.shipping_phone,
            shipping_address=dto.shipping_address,
            note=dto.note
        )
        
        return await self.order_repository.create(order, order_items)
